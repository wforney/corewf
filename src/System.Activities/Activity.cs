// This file is part of Core WF which is licensed under the MIT license. See LICENSE file in the
// project root for full license information.

namespace System.Activities
{
    using Portable.Xaml.Markup;

    using System;
    using System.Activities.DynamicUpdate;
    using System.Activities.Expressions;
    using System.Activities.Hosting;
    using System.Activities.Internals;
    using System.Activities.Runtime;
    using System.Activities.Validation;
    using System.Activities.XamlIntegration;
    using System.Collections.Generic;
    using System.Collections.ObjectModel;
    using System.ComponentModel;
    using System.Diagnostics.CodeAnalysis;
    using System.Globalization;
    using System.Threading;

    /// <summary>
    /// The Activity class.
    /// </summary>
    [ContentProperty("Implementation")]
    public abstract partial class Activity
    {
        /// <summary>
        /// The empty constraints
        /// </summary>
        internal static readonly ReadOnlyCollection<Constraint> EmptyConstraints = new ReadOnlyCollection<Constraint>(Array.Empty<Constraint>());

        /// <summary>
        /// The generated argument prefix
        /// </summary>
        private const string generatedArgumentPrefix = "Argument";

        /// <summary>
        /// The empty arguments
        /// </summary>
        private static readonly IList<RuntimeArgument> emptyArguments = new List<RuntimeArgument>(0);

        /// <summary>
        /// The empty children
        /// </summary>
        private static readonly IList<Activity> emptyChildren = new List<Activity>(0);

        /// <summary>
        /// The empty delegates
        /// </summary>
        private static readonly IList<ActivityDelegate> emptyDelegates = new List<ActivityDelegate>(0);

        /// <summary>
        /// The empty variables
        /// </summary>
        private static readonly IList<Variable> emptyVariables = new List<Variable>(0);

        /// <summary>
        /// The next cache identifier
        /// </summary>
        private static int nextCacheId;

        /// <summary>
        /// The constraints
        /// </summary>
        private Collection<Constraint> constraints;

        /// <summary>
        /// The display name
        /// </summary>
        private string displayName;

        /// <summary>
        /// The identifier
        /// </summary>
        private int id;

        /// <summary>
        /// The is display name set
        /// </summary>
        private bool isDisplayNameSet;

        /// <summary>
        /// For a given cacheId this tells us whether we've called InternalCacheMetadata yet or not
        /// </summary>
        private CacheStates isMetadataCached;

        /// <summary>
        /// The is subtree empty
        /// </summary>
        private bool? isSubtreeEmpty;

        /// <summary>
        /// The qualified identifier
        /// </summary>
        private QualifiedId qualifiedId;

        /// <summary>
        /// The root properties
        /// </summary>
        private RootProperties rootProperties;

        /// <summary>
        /// The runtime implementation
        /// </summary>
        private Activity runtimeImplementation;

        /// <summary>
        /// The temporary automatic generated arguments
        /// </summary>
        private IList<RuntimeArgument> tempAutoGeneratedArguments;

        /// <summary>
        /// The temporary validation errors
        /// </summary>
        private IList<ValidationError> tempValidationErrors;

        /// <summary>
        /// Initializes a new instance of the <see cref="Activity" /> class.
        /// </summary>
        /// <remarks>alternatives are extended through DynamicActivity, CodeActivity, and NativeActivity</remarks>
        protected Activity() => this.ThisLock = new object();

        /// <summary>
        /// Gets or sets the display name.
        /// </summary>
        /// <value>The display name.</value>
        public string DisplayName
        {
            get
            {
                if (!this.isDisplayNameSet && string.IsNullOrEmpty(this.displayName))
                {
                    this.displayName = ActivityUtilities.GetDisplayName(this);
                }

                return this.displayName;
            }
            set
            {
                this.displayName = value ?? string.Empty;
                this.isDisplayNameSet = true;
            }
        }

        /// <summary>
        /// Gets the host environment.
        /// </summary>
        /// <value>The host environment.</value>
        internal LocationReferenceEnvironment HostEnvironment =>
            this.RootActivity != null && this.RootActivity.rootProperties != null
                    ? this.RootActivity.rootProperties.HostEnvironment
                    : null;

        /// <summary>
        /// Gets the identifier.
        /// </summary>
        /// <value>The identifier.</value>
        public string Id => this.id == 0 ? null : this.QualifiedId.ToString();

        /// <summary>
        /// Gets or sets the implementation.
        /// </summary>
        /// <value>The implementation.</value>
        [XamlDeferLoad(typeof(FuncDeferringLoader), typeof(Activity))]
        [DefaultValue(null)]
        [Browsable(false)]
        [Ambient]
        public virtual Func<Activity> Implementation
        {
            get;
            set;
        }

        /// <summary>
        /// Gets the children.
        /// </summary>
        /// <value>The children.</value>
        internal IList<Activity> Children { get; private set; }

        /// <summary>
        /// Gets the default extensions count.
        /// </summary>
        /// <value>The default extensions count.</value>
        internal int DefaultExtensionsCount
        {
            get
            {
                Fx.Assert(this.rootProperties != null || Diagnostics.Debugger.IsAttached, "only callable on the root");
                return this.rootProperties.DefaultExtensionsCount;
            }
        }

        /// <summary>
        /// Gets the delegates.
        /// </summary>
        /// <value>The delegates.</value>
        internal IList<ActivityDelegate> Delegates { get; private set; }

        /// <summary>
        /// Gets or sets the equivalence information.
        /// </summary>
        /// <value>The equivalence information.</value>
        internal ValidationHelper.OverloadGroupEquivalenceInfo EquivalenceInfo
        {
            get
            {
                Fx.Assert(this.rootProperties != null || Diagnostics.Debugger.IsAttached, "This should only be called on the root.");
                return this.rootProperties.EquivalenceInfo;
            }
            set
            {
                Fx.Assert(this.rootProperties != null, "This should only be called on the root.");
                this.rootProperties.EquivalenceInfo = value;
            }
        }

        /// <summary>
        /// Gets the handler of.
        /// </summary>
        /// <value>The handler of.</value>
        internal ActivityDelegate HandlerOf
        {
            get;
            private set;
        }

        /// <summary>
        /// Gets or sets a value indicating whether this instance has been associated with an instance.
        /// </summary>
        /// <value>
        /// <c>true</c> if this instance has been associated with an instance; otherwise, <c>false</c>.
        /// </value>
        internal bool HasBeenAssociatedWithAnInstance
        {
            get => this.rootProperties == null
                    ? !this.IsMetadataCached || this.RootActivity == null || this.RootActivity.rootProperties == null
                        ? false
                        : this.RootActivity.rootProperties.HasBeenAssociatedWithAnInstance
                    : this.rootProperties.HasBeenAssociatedWithAnInstance;
            set
            {
                Fx.Assert(this.rootProperties != null, "This should only be called on the root and we should already be cached.");
                Fx.Assert(value, "We really only let you set this to true.");

                this.rootProperties.HasBeenAssociatedWithAnInstance = value;
            }
        }

        /// <summary>
        /// Gets a value indicating whether this instance has non empty subtree.
        /// </summary>
        /// <value><c>true</c> if this instance has non empty subtree; otherwise, <c>false</c>.</value>
        internal bool HasNonEmptySubtree
        {
            get
            {
                if (this.isSubtreeEmpty.HasValue)
                {
                    return !this.isSubtreeEmpty.Value;
                }
                else
                {
                    if (this.Children.Count > 0 || this.ImplementationChildren.Count > 0 || this.ImportedChildren.Count > 0 ||
                        this.Delegates.Count > 0 || this.ImplementationDelegates.Count > 0 || this.ImportedDelegates.Count > 0 ||
                        this.RuntimeVariables.Count > 0 || this.ImplementationVariables.Count > 0 ||
                        this.RuntimeArguments.Count > 0)
                    {
                        this.isSubtreeEmpty = false;
                    }
                    else
                    {
                        this.isSubtreeEmpty = true;
                    }

                    return !this.isSubtreeEmpty.Value;
                }
            }
        }

        /// <summary>
        /// Gets a value indicating whether this instance has started caching metadata.
        /// </summary>
        /// <value><c>true</c> if this instance has started caching metadata; otherwise, <c>false</c>.</value>
        internal bool HasStartedCachingMetadata => this.isMetadataCached != CacheStates.Uncached;

        /// <summary>
        /// Gets a value indicating whether this instance has temporary violations.
        /// </summary>
        /// <value><c>true</c> if this instance has temporary violations; otherwise, <c>false</c>.</value>
        internal bool HasTempViolations => this.tempValidationErrors != null && this.tempValidationErrors.Count > 0;

        /// <summary>
        /// Gets the implementation children.
        /// </summary>
        /// <value>The implementation children.</value>
        internal IList<Activity> ImplementationChildren { get; private set; }

        /// <summary>
        /// Gets the implementation delegates.
        /// </summary>
        /// <value>The implementation delegates.</value>
        internal IList<ActivityDelegate> ImplementationDelegates { get; private set; }

        /// <summary>
        /// Gets or sets the implementation environment.
        /// </summary>
        /// <value>The implementation environment.</value>
        internal LocationReferenceEnvironment ImplementationEnvironment { get; set; }

        /// <summary>
        /// Gets the implementation variables.
        /// </summary>
        /// <value>The implementation variables.</value>
        internal IList<Variable>? ImplementationVariables { get; private set; }

        /// <summary>
        /// Gets the imported children.
        /// </summary>
        /// <value>The imported children.</value>
        internal IList<Activity> ImportedChildren { get; private set; }

        /// <summary>
        /// Gets the imported delegates.
        /// </summary>
        /// <value>The imported delegates.</value>
        internal IList<ActivityDelegate> ImportedDelegates { get; private set; }

        /// <summary>
        /// Gets a value indicating whether [internal can induce idle].
        /// </summary>
        /// <value><c>true</c> if [internal can induce idle]; otherwise, <c>false</c>.</value>
        internal virtual bool InternalCanInduceIdle => false;

        /// <summary>
        /// Gets or sets the internal identifier.
        /// </summary>
        /// <value>The internal identifier.</value>
        internal int InternalId
        {
            get => this.id;
            set
            {
                Fx.Assert(value != 0, "0 is an invalid ID");
                this.ClearIdInfo();
                this.id = value;
            }
        }

        /// <summary>
        /// Gets a value indicating whether this instance is activity with result.
        /// </summary>
        /// <value><c>true</c> if this instance is activity with result; otherwise, <c>false</c>.</value>
        internal virtual bool IsActivityWithResult => false;

        /// <summary>
        /// Gets a value indicating whether this instance is expression root.
        /// </summary>
        /// <value><c>true</c> if this instance is expression root; otherwise, <c>false</c>.</value>
        internal bool IsExpressionRoot => this.RelationshipToParent == RelationshipType.ArgumentExpression;

        /// <summary>
        /// Gets a value indicating whether this instance is fast path.
        /// </summary>
        /// <value><c>true</c> if this instance is fast path; otherwise, <c>false</c>.</value>
        internal bool IsFastPath => this.SkipArgumentResolution && this.IsActivityWithResult;

        /// <summary>
        /// Gets a value indicating whether this instance is metadata cached.
        /// </summary>
        /// <value><c>true</c> if this instance is metadata cached; otherwise, <c>false</c>.</value>
        internal bool IsMetadataCached => this.isMetadataCached != CacheStates.Uncached;

        /// <summary>
        /// Gets a value indicating whether this instance is metadata fully cached.
        /// </summary>
        /// <value><c>true</c> if this instance is metadata fully cached; otherwise, <c>false</c>.</value>
        internal bool IsMetadataFullyCached => (this.isMetadataCached & CacheStates.Full) == CacheStates.Full;

        /// <summary>
        /// Gets a value indicating whether this instance is runtime ready.
        /// </summary>
        /// <value><c>true</c> if this instance is runtime ready; otherwise, <c>false</c>.</value>
        internal bool IsRuntimeReady => (this.isMetadataCached & CacheStates.RuntimeReady) == CacheStates.RuntimeReady;

        /// <summary>
        /// Gets or sets the member of.
        /// </summary>
        /// <value>The member of.</value>
        internal IdSpace MemberOf { get; set; }

        /// <summary>
        /// Gets or sets the origin.
        /// </summary>
        /// <value>The origin.</value>
        internal object? Origin { get; set; }

        /// <summary>
        /// Gets or sets the overload groups.
        /// </summary>
        /// <value>The overload groups.</value>
        internal Dictionary<string, List<RuntimeArgument>> OverloadGroups
        {
            get
            {
                Fx.Assert(this.rootProperties != null || Diagnostics.Debugger.IsAttached, "This should only be called on the root.");
                return this.rootProperties.OverloadGroups;
            }
            set
            {
                Fx.Assert(this.rootProperties != null, "This should only be called on the root.");
                this.rootProperties.OverloadGroups = value;
            }
        }

        /// <summary>
        /// Gets the parent.
        /// </summary>
        /// <value>The parent.</value>
        internal Activity Parent
        {
            get;
            private set;
        }

        /// <summary>
        /// Gets or sets the parent of.
        /// </summary>
        /// <value>The parent of.</value>
        internal IdSpace ParentOf
        {
            get;
            set;
        }

        /// <summary>
        /// Gets or sets the public environment.
        /// </summary>
        /// <value>The public environment.</value>
        internal LocationReferenceEnvironment PublicEnvironment
        {
            get;
            set;
        }

        /// <summary>
        /// Gets the qualified identifier.
        /// </summary>
        /// <value>The qualified identifier.</value>
        internal QualifiedId QualifiedId
        {
            get
            {
                if (this.qualifiedId == null)
                {
                    this.qualifiedId = new QualifiedId(this);
                }

                return this.qualifiedId;
            }
        }

        /// <summary>
        /// Gets the relationship to parent.
        /// </summary>
        /// <value>The relationship to parent.</value>
        internal RelationshipType RelationshipToParent { get; private set; }

        /// <summary>
        /// Gets or sets the required arguments not in overload groups.
        /// </summary>
        /// <value>The required arguments not in overload groups.</value>
        internal List<RuntimeArgument> RequiredArgumentsNotInOverloadGroups
        {
            get
            {
                Fx.Assert(this.rootProperties != null || Diagnostics.Debugger.IsAttached, "This should only be called on the root.");
                return this.rootProperties.RequiredArgumentsNotInOverloadGroups;
            }
            set
            {
                Fx.Assert(this.rootProperties != null, "This should only be called on the root.");
                this.rootProperties.RequiredArgumentsNotInOverloadGroups = value;
            }
        }

        /// <summary>
        /// Gets the required extension types count.
        /// </summary>
        /// <value>The required extension types count.</value>
        internal int RequiredExtensionTypesCount
        {
            get
            {
                Fx.Assert(this.rootProperties != null || Diagnostics.Debugger.IsAttached, "only callable on the root");
                return this.rootProperties.RequiredExtensionTypesCount;
            }
        }

        /// <summary>
        /// Gets the root activity.
        /// </summary>
        /// <value>The root activity.</value>
        internal Activity RootActivity { get; private set; }

        /// <summary>
        /// Gets the runtime arguments.
        /// </summary>
        /// <value>The runtime arguments.</value>
        internal IList<RuntimeArgument> RuntimeArguments { get; private set; }

        /// <summary>
        /// Gets the runtime constraints.
        /// </summary>
        /// <value>The runtime constraints.</value>
        internal IList<Constraint> RuntimeConstraints => this.InternalGetConstraints();

        /// <summary>
        /// Gets the runtime variables.
        /// </summary>
        /// <value>The runtime variables.</value>
        internal IList<Variable> RuntimeVariables { get; private set; }

        /// <summary>
        /// Gets or sets a value indicating whether [skip argument resolution].
        /// </summary>
        /// <value><c>true</c> if [skip argument resolution]; otherwise, <c>false</c>.</value>
        internal bool SkipArgumentResolution
        {
            get;
            set;
        }

        /// <summary>
        /// Gets the symbol count.
        /// </summary>
        /// <value>The symbol count.</value>
        internal int SymbolCount { get; private set; }

        /// <summary>
        /// Gets the this lock.
        /// </summary>
        /// <value>The this lock.</value>
        internal object ThisLock { get; }

        // This flag governs special behavior that we need to keep for back-compat on activities
        // that implemented TryGetValue in 4.0.
        /// <summary>
        /// Gets or sets a value indicating whether [use old fast path].
        /// </summary>
        /// <value><c>true</c> if [use old fast path]; otherwise, <c>false</c>.</value>
        internal bool UseOldFastPath
        {
            get;
            set;
        }

        /// <summary>
        /// Gets the cache identifier.
        /// </summary>
        /// <value>The cache identifier.</value>
        protected internal int CacheId { get; private set; }

        /// <summary>
        /// Gets or sets the implementation version.
        /// </summary>
        /// <value>The implementation version.</value>
        [TypeConverter(typeof(ImplementationVersionConverter))]
        [DefaultValue(null)]
        protected internal virtual Version ImplementationVersion
        {
            get;
            set;
        }

        /// <summary>
        /// Gets the constraints.
        /// </summary>
        /// <value>The constraints.</value>
        protected Collection<Constraint> Constraints
        {
            get
            {
                if (this.constraints == null)
                {
                    this.constraints = new Collection<Constraint>();
                }

                return this.constraints;
            }
        }

        /// <summary>
        /// Shoulds the display name of the serialize.
        /// </summary>
        /// <returns><c>true</c> if XXXX, <c>false</c> otherwise.</returns>
        [EditorBrowsable(EditorBrowsableState.Never)]
        public bool ShouldSerializeDisplayName() => this.isDisplayNameSet;

        /// <summary>
        /// Returns a <see cref="System.String" /> that represents this instance.
        /// </summary>
        /// <returns>A <see cref="System.String" /> that represents this instance.</returns>
        public override string ToString() => string.Format(CultureInfo.CurrentCulture, "{0}: {1}", this.Id, this.DisplayName);

        /// <summary>
        /// Nulls the check.
        /// </summary>
        /// <typeparam name="T"></typeparam>
        /// <param name="obj">The object.</param>
        /// <returns><c>true</c> if XXXX, <c>false</c> otherwise.</returns>
        internal static bool NullCheck<T>(T obj) => obj == null;

        /// <summary>
        /// Adds the argument.
        /// </summary>
        /// <param name="argument">The argument.</param>
        /// <param name="createEmptyBindings">if set to <c>true</c> [create empty bindings].</param>
        internal void AddArgument(RuntimeArgument argument, bool createEmptyBindings)
        {
            if (this.RuntimeArguments == null)
            {
                this.RuntimeArguments = new Collection<RuntimeArgument>();
            }

            argument.SetupBinding(this, createEmptyBindings);

            var insertionIndex = this.RuntimeArguments.BinarySearch(argument, RuntimeArgument.EvaluationOrderComparer);
            if (insertionIndex < 0)
            {
                this.RuntimeArguments.Insert(~insertionIndex, argument);
            }
            else
            {
                this.RuntimeArguments.Insert(insertionIndex, argument);
            }
        }

        /// <summary>
        /// Adds the child.
        /// </summary>
        /// <param name="child">The child.</param>
        internal void AddChild(Activity child)
        {
            if (this.Children == null)
            {
                this.Children = new Collection<Activity>();
            }

            this.Children.Add(child);
        }

        /// <summary>
        /// Adds the default extension provider.
        /// </summary>
        /// <typeparam name="T"></typeparam>
        /// <param name="extensionProvider">The extension provider.</param>
        internal void AddDefaultExtensionProvider<T>(Func<T> extensionProvider)
            where T : class
        {
            Fx.Assert(extensionProvider != null, "caller must verify");
            Fx.Assert(this.RootActivity != null && this.RootActivity.rootProperties != null, "need a valid root");
            this.RootActivity.rootProperties.AddDefaultExtensionProvider(extensionProvider);
        }

        /// <summary>
        /// Adds the delegate.
        /// </summary>
        /// <param name="activityDelegate">The activity delegate.</param>
        internal void AddDelegate(ActivityDelegate activityDelegate)
        {
            if (this.Delegates == null)
            {
                this.Delegates = new Collection<ActivityDelegate>();
            }

            this.Delegates.Add(activityDelegate);
        }

        /// <summary>
        /// Adds the implementation child.
        /// </summary>
        /// <param name="implementationChild">The implementation child.</param>
        internal void AddImplementationChild(Activity implementationChild)
        {
            if (this.ImplementationChildren == null)
            {
                this.ImplementationChildren = new Collection<Activity>();
            }

            this.ImplementationChildren.Add(implementationChild);
        }

        /// <summary>
        /// Adds the implementation delegate.
        /// </summary>
        /// <param name="implementationDelegate">The implementation delegate.</param>
        internal void AddImplementationDelegate(ActivityDelegate implementationDelegate)
        {
            if (this.ImplementationDelegates == null)
            {
                this.ImplementationDelegates = new Collection<ActivityDelegate>();
            }

            this.ImplementationDelegates.Add(implementationDelegate);
        }

        /// <summary>
        /// Adds the implementation variable.
        /// </summary>
        /// <param name="implementationVariable">The implementation variable.</param>
        internal void AddImplementationVariable(Variable implementationVariable)
        {
            if (this.ImplementationVariables == null)
            {
                this.ImplementationVariables = new Collection<Variable>();
            }

            this.ImplementationVariables.Add(implementationVariable);
        }

        /// <summary>
        /// Adds the imported child.
        /// </summary>
        /// <param name="importedChild">The imported child.</param>
        internal void AddImportedChild(Activity importedChild)
        {
            if (this.ImportedChildren == null)
            {
                this.ImportedChildren = new Collection<Activity>();
            }

            this.ImportedChildren.Add(importedChild);
        }

        /// <summary>
        /// Adds the imported delegate.
        /// </summary>
        /// <param name="importedDelegate">The imported delegate.</param>
        internal void AddImportedDelegate(ActivityDelegate importedDelegate)
        {
            if (this.ImportedDelegates == null)
            {
                this.ImportedDelegates = new Collection<ActivityDelegate>();
            }

            this.ImportedDelegates.Add(importedDelegate);
        }

        /// <summary>
        /// Adds the temporary automatic generated argument.
        /// </summary>
        /// <param name="argumentType">Type of the argument.</param>
        /// <param name="direction">The direction.</param>
        /// <returns>RuntimeArgument.</returns>
        internal RuntimeArgument AddTempAutoGeneratedArgument(Type argumentType, ArgumentDirection direction)
        {
            if (this.tempAutoGeneratedArguments == null)
            {
                this.tempAutoGeneratedArguments = new Collection<RuntimeArgument>();
            }

            var name = generatedArgumentPrefix + this.tempAutoGeneratedArguments.Count.ToString(CultureInfo.InvariantCulture);
            var argument = new RuntimeArgument(name, argumentType, direction);
            this.tempAutoGeneratedArguments.Add(argument);

            return argument;
        }

        /// <summary>
        /// Adds the temporary validation error.
        /// </summary>
        /// <param name="validationError">The validation error.</param>
        internal void AddTempValidationError(ValidationError validationError)
        {
            if (this.tempValidationErrors == null)
            {
                this.tempValidationErrors = new Collection<ValidationError>();
            }

            this.tempValidationErrors.Add(validationError);
        }

        /// <summary>
        /// Adds the variable.
        /// </summary>
        /// <param name="variable">The variable.</param>
        internal void AddVariable(Variable variable)
        {
            if (this.RuntimeVariables == null)
            {
                this.RuntimeVariables = new Collection<Variable>();
            }

            this.RuntimeVariables.Add(variable);
        }

        /// <summary>
        /// Determines whether this instance [can be scheduled by] the specified parent.
        /// </summary>
        /// <param name="parent">The parent.</param>
        /// <returns>
        /// <c>true</c> if this instance [can be scheduled by] the specified parent; otherwise, <c>false</c>.
        /// </returns>
        internal bool CanBeScheduledBy(Activity parent) =>
            // fast path if we're the sole (or first) child
            ReferenceEquals(parent, this.Parent)
                ? this.RelationshipToParent == RelationshipType.ImplementationChild || this.RelationshipToParent == RelationshipType.Child
                : parent.Children.Contains(this) || parent.ImplementationChildren.Contains(this);

        /// <summary>
        /// Clears the cached information.
        /// </summary>
        internal void ClearCachedInformation()
        {
            this.ClearCachedMetadata();
            this.isMetadataCached = CacheStates.Uncached;
        }

        /// <summary>
        /// Clears the identifier information.
        /// </summary>
        internal void ClearIdInfo()
        {
            if (this.ParentOf != null)
            {
                this.ParentOf.Dispose();
                this.ParentOf = null;
            }

            this.id = 0;
            this.qualifiedId = null;
        }

        /// <summary>
        /// Declares the singleton activity.
        /// </summary>
        /// <param name="name">The name.</param>
        /// <param name="activity">The activity.</param>
        internal void DeclareSingletonActivity(string name, Activity activity)
        {
            if (this.RootActivity != null && this.RootActivity.rootProperties != null)
            {
                this.RootActivity.rootProperties.DeclareSingletonActivity(name, activity);
            }
        }

        /// <summary>
        /// Gets the activity extension information.
        /// </summary>
        /// <param name="activityExtensionProviders">The activity extension providers.</param>
        /// <param name="requiredActivityExtensionTypes">The required activity extension types.</param>
        /// <returns><c>true</c> if XXXX, <c>false</c> otherwise.</returns>
        internal bool GetActivityExtensionInformation(
            out Dictionary<Type, WorkflowInstanceExtensionProvider> activityExtensionProviders,
            out HashSet<Type> requiredActivityExtensionTypes)
        {
            Fx.Assert(this.rootProperties != null, "only callable on the root");
            return this.rootProperties.GetActivityExtensionInformation(out activityExtensionProviders, out requiredActivityExtensionTypes);
        }

        /// <summary>
        /// Gets the parent environment.
        /// </summary>
        /// <returns>LocationReferenceEnvironment.</returns>
        internal LocationReferenceEnvironment GetParentEnvironment()
        {
            LocationReferenceEnvironment parentEnvironment = null;

            if (this.Parent == null)
            {
                Fx.Assert(this.rootProperties != null, "Root properties must be available now.");

                parentEnvironment = new ActivityLocationReferenceEnvironment(this.rootProperties.HostEnvironment) { InternalRoot = this };
            }
            else
            {
                switch (this.RelationshipToParent)
                {
                    case RelationshipType.ArgumentExpression:
                        parentEnvironment = this.Parent.PublicEnvironment.Parent;

                        if (parentEnvironment == null)
                        {
                            parentEnvironment = this.RootActivity.rootProperties.HostEnvironment;
                        }

                        break;

                    case RelationshipType.DelegateHandler:
                        Fx.Assert(this.HandlerOf != null, "Must have the parent delegate set");

                        parentEnvironment = this.HandlerOf.Environment;
                        break;

                    case RelationshipType.Child:
                    case RelationshipType.ImportedChild:
                    case RelationshipType.VariableDefault:
                        parentEnvironment = this.Parent.PublicEnvironment;
                        break;

                    case RelationshipType.ImplementationChild:
                        parentEnvironment = this.Parent.ImplementationEnvironment;
                        break;
                }
            }

            return parentEnvironment;
        }

        /// <summary>
        /// Gets the singleton activity.
        /// </summary>
        /// <param name="name">The name.</param>
        /// <returns>Activity.</returns>
        internal Activity GetSingletonActivity(string name) => this.RootActivity == null || this.RootActivity.rootProperties == null
                ? null
                : this.RootActivity.rootProperties.GetSingletonActivity(name);

        /// <summary>
        /// Initializes as root.
        /// </summary>
        /// <param name="hostEnvironment">The host environment.</param>
        internal void InitializeAsRoot(LocationReferenceEnvironment hostEnvironment)
        {
            // We're being treated as the root of the workflow
            this.Parent = null;
            this.ParentOf = null;

            Interlocked.CompareExchange(ref nextCacheId, 1, int.MaxValue);
            this.CacheId = Interlocked.Increment(ref nextCacheId);

            this.ClearCachedInformation();

            this.MemberOf = new IdSpace();
            this.rootProperties = new RootProperties
            {
                HostEnvironment = hostEnvironment
            };
            this.RootActivity = this;
        }

        /// <summary>
        /// Initializes the relationship.
        /// </summary>
        /// <param name="activityDelegate">The activity delegate.</param>
        /// <param name="collectionType">Type of the collection.</param>
        /// <param name="validationErrors">The validation errors.</param>
        /// <returns><c>true</c> if XXXX, <c>false</c> otherwise.</returns>
        internal bool InitializeRelationship(ActivityDelegate activityDelegate, ActivityCollectionType collectionType, ref IList<ValidationError> validationErrors)
        {
            if (this.CacheId == activityDelegate.Owner.CacheId)
            {
                // This means that we already have a parent and a delegate is trying to initialize a
                // relationship. Delegate handlers MUST be declared.

                ActivityUtilities.Add(
                    ref validationErrors,
                    new ValidationError(
                        SR.ActivityDelegateHandlersMustBeDeclarations(
                            this.DisplayName,
                            activityDelegate.Owner.DisplayName,
                            this.Parent.DisplayName),
                        false,
                        activityDelegate.Owner));

                return false;
            }

            if (this.InitializeRelationship(
                activityDelegate.Owner,
                collectionType != ActivityCollectionType.Implementation,
                RelationshipType.DelegateHandler,
                ref validationErrors))
            {
                this.HandlerOf = activityDelegate;

                return true;
            }

            return false;
        }

        /// <summary>
        /// Initializes the relationship.
        /// </summary>
        /// <param name="argument">The argument.</param>
        /// <param name="validationErrors">The validation errors.</param>
        /// <returns><c>true</c> if XXXX, <c>false</c> otherwise.</returns>
        internal bool InitializeRelationship(RuntimeArgument argument, ref IList<ValidationError> validationErrors) =>
            this.InitializeRelationship(argument.Owner, true, RelationshipType.ArgumentExpression, ref validationErrors);

        /// <summary>
        /// Initializes the relationship.
        /// </summary>
        /// <param name="variable">The variable.</param>
        /// <param name="isPublic">if set to <c>true</c> [is public].</param>
        /// <param name="validationErrors">The validation errors.</param>
        /// <returns><c>true</c> if XXXX, <c>false</c> otherwise.</returns>
        internal bool InitializeRelationship(Variable variable, bool isPublic, ref IList<ValidationError> validationErrors) =>
            this.InitializeRelationship(variable.Owner, isPublic, RelationshipType.VariableDefault, ref validationErrors);

        /// <summary>
        /// Initializes the relationship.
        /// </summary>
        /// <param name="parent">The parent.</param>
        /// <param name="collectionType">Type of the collection.</param>
        /// <param name="validationErrors">The validation errors.</param>
        /// <returns><c>true</c> if XXXX, <c>false</c> otherwise.</returns>
        internal bool InitializeRelationship(Activity parent, ActivityCollectionType collectionType, ref IList<ValidationError> validationErrors)
        {
            var relationshipType = RelationshipType.Child;
            switch (collectionType)
            {
                case ActivityCollectionType.Imports:
                    relationshipType = RelationshipType.ImportedChild;
                    break;

                case ActivityCollectionType.Implementation:
                    relationshipType = RelationshipType.ImplementationChild;
                    break;
            }

            return this.InitializeRelationship(parent, collectionType != ActivityCollectionType.Implementation, relationshipType, ref validationErrors);
        }

        /// <summary>
        /// subclasses are responsible for creating/disposing the necessary contexts
        /// </summary>
        /// <param name="instance">The instance.</param>
        /// <param name="executor">The executor.</param>
        /// <param name="terminationReason">The termination reason.</param>
        internal virtual void InternalAbort(ActivityInstance instance, ActivityExecutor executor, Exception terminationReason)
        {
        }

        /// <summary>
        /// Internals the cache metadata.
        /// </summary>
        /// <param name="createEmptyBindings">if set to <c>true</c> [create empty bindings].</param>
        /// <param name="validationErrors">The validation errors.</param>
        internal void InternalCacheMetadata(bool createEmptyBindings, ref IList<ValidationError> validationErrors)
        {
            this.OnInternalCacheMetadata(createEmptyBindings);

            if (this.tempAutoGeneratedArguments != null)
            {
                Fx.Assert(this.tempAutoGeneratedArguments.Count > 0, "We should only have a non-null value here if we generated an argument");
                if (!this.SkipArgumentResolution)
                {
                    ActivityUtilities.Add(ref validationErrors, new ValidationError(
                        SR.PublicReferencesOnActivityRequiringArgumentResolution(this.DisplayName), false, this));
                }

                if (this.RuntimeArguments == null)
                {
                    this.RuntimeArguments = this.tempAutoGeneratedArguments;
                }
                else
                {
                    for (var i = 0; i < this.tempAutoGeneratedArguments.Count; i++)
                    {
                        this.RuntimeArguments.Add(this.tempAutoGeneratedArguments[i]);
                    }
                }

                this.tempAutoGeneratedArguments = null;
            }

            if (this.RuntimeArguments != null && this.RuntimeArguments.Count > 1)
            {
                ActivityValidationServices.ValidateEvaluationOrder(this.RuntimeArguments, this, ref this.tempValidationErrors);
            }

            if (this.tempValidationErrors != null)
            {
                if (validationErrors == null)
                {
                    validationErrors = new List<ValidationError>();
                }

                for (var i = 0; i < this.tempValidationErrors.Count; i++)
                {
                    var validationError = this.tempValidationErrors[i];

                    validationError.Source = this;
                    validationError.Id = this.Id;

                    validationErrors.Add(validationError);
                }

                this.tempValidationErrors = null;
            }

            if (this.RuntimeArguments == null)
            {
                this.RuntimeArguments = emptyArguments;
            }
            else
            {
                this.SymbolCount += this.RuntimeArguments.Count;
            }

            if (this.RuntimeVariables == null)
            {
                this.RuntimeVariables = emptyVariables;
            }
            else
            {
                this.SymbolCount += this.RuntimeVariables.Count;
            }

            if (this.ImplementationVariables == null)
            {
                this.ImplementationVariables = emptyVariables;
            }
            else
            {
                this.SymbolCount += this.ImplementationVariables.Count;
            }

            if (this.Children == null)
            {
                this.Children = emptyChildren;
            }

            if (this.ImportedChildren == null)
            {
                this.ImportedChildren = emptyChildren;
            }

            if (this.ImplementationChildren == null)
            {
                this.ImplementationChildren = emptyChildren;
            }

            if (this.Delegates == null)
            {
                this.Delegates = emptyDelegates;
            }

            if (this.ImportedDelegates == null)
            {
                this.ImportedDelegates = emptyDelegates;
            }

            if (this.ImplementationDelegates == null)
            {
                this.ImplementationDelegates = emptyDelegates;
            }

            this.isMetadataCached = CacheStates.Partial;
        }

        /// <summary>
        /// Internals the cancel.
        /// </summary>
        /// <param name="instance">The instance.</param>
        /// <param name="executor">The executor.</param>
        /// <param name="bookmarkManager">The bookmark manager.</param>
        internal virtual void InternalCancel(ActivityInstance instance, ActivityExecutor executor, BookmarkManager bookmarkManager)
        {
            var context = executor.NativeActivityContextPool.Acquire();
            try
            {
                context.Initialize(instance, executor, bookmarkManager);
                context.Cancel();
            }
            finally
            {
                context.Dispose();
                executor.NativeActivityContextPool.Release(context);
            }
        }

        /// <summary>
        /// subclasses are responsible for creating/disposing the necessary contexts
        /// </summary>
        /// <param name="instance">The instance.</param>
        /// <param name="executor">The executor.</param>
        /// <param name="bookmarkManager">The bookmark manager.</param>
        internal virtual void InternalExecute(ActivityInstance instance, ActivityExecutor executor, BookmarkManager bookmarkManager)
        {
            if (this.runtimeImplementation != null)
            {
                executor.ScheduleActivity(this.runtimeImplementation, instance, null, null, null);
            }
        }

        /// <summary>
        /// Internals the get constraints.
        /// </summary>
        /// <returns>IList&lt;Constraint&gt;.</returns>
        internal virtual IList<Constraint> InternalGetConstraints() =>
            this.constraints == null || this.constraints.Count <= 0 ? (IList<Constraint>)EmptyConstraints : this.constraints;

        /// <summary>
        /// Determines whether [is result argument] [the specified argument].
        /// </summary>
        /// <param name="argument">The argument.</param>
        /// <returns>
        /// <c>true</c> if [is result argument] [the specified argument]; otherwise, <c>false</c>.
        /// </returns>
        internal virtual bool IsResultArgument(RuntimeArgument argument) => false;

        /// <summary>
        /// Determines whether [is singleton activity declared] [the specified name].
        /// </summary>
        /// <param name="name">The name.</param>
        /// <returns>
        /// <c>true</c> if [is singleton activity declared] [the specified name]; otherwise, <c>false</c>.
        /// </returns>
        internal bool IsSingletonActivityDeclared(string name) => this.RootActivity == null || this.RootActivity.rootProperties == null
                ? false
                : this.RootActivity.rootProperties.IsSingletonActivityDeclared(name);

        /// <summary>
        /// Called when [internal cache metadata].
        /// </summary>
        /// <param name="createEmptyBindings">if set to <c>true</c> [create empty bindings].</param>
        internal virtual void OnInternalCacheMetadata(bool createEmptyBindings)
        {
            // By running CacheMetadata first we allow the user to set their Implementation during CacheMetadata.
            var metadata = new ActivityMetadata(this, this.GetParentEnvironment(), createEmptyBindings);
            this.CacheMetadata(metadata);
            metadata.Dispose();

            this.runtimeImplementation = this.Implementation == null ? null : this.Implementation();

            if (this.runtimeImplementation != null)
            {
                this.SetImplementationChildrenCollection(new Collection<Activity>
                {
                    this.runtimeImplementation
                });
            }
        }

        /// <summary>
        /// Called when [internal create dynamic update map].
        /// </summary>
        /// <param name="finalizer">The finalizer.</param>
        /// <param name="matcher">The matcher.</param>
        /// <param name="originalActivity">The original activity.</param>
        internal virtual void OnInternalCreateDynamicUpdateMap(DynamicUpdateMapBuilder.Finalizer finalizer,
            DynamicUpdateMapBuilder.IDefinitionMatcher matcher, Activity originalActivity)
        {
            var metadata = new UpdateMapMetadata(finalizer, matcher, this);
            try
            {
                this.OnCreateDynamicUpdateMap(metadata, originalActivity);
            }
            finally
            {
                metadata.Dispose();
            }
        }

        /// <summary>
        /// Requires the extension.
        /// </summary>
        /// <param name="extensionType">Type of the extension.</param>
        internal void RequireExtension(Type extensionType)
        {
            Fx.Assert(extensionType != null && !extensionType.IsValueType, "caller should verify we have a valid reference type");
            Fx.Assert(this.RootActivity != null && this.RootActivity.rootProperties != null, "need a valid root");
            this.RootActivity.rootProperties.RequireExtension(extensionType);
        }

        /// <summary>
        /// Resets the temporary automatic generated arguments.
        /// </summary>
        internal void ResetTempAutoGeneratedArguments() => this.tempAutoGeneratedArguments = null;

        /// <summary>
        /// Sets the arguments collection.
        /// </summary>
        /// <param name="arguments">The arguments.</param>
        /// <param name="createEmptyBindings">if set to <c>true</c> [create empty bindings].</param>
        internal void SetArgumentsCollection(Collection<RuntimeArgument> arguments, bool createEmptyBindings)
        {
            this.RuntimeArguments = arguments;

            // Arguments should always be "as bound as possible"
            if (this.RuntimeArguments != null && this.RuntimeArguments.Count > 0)
            {
                for (var i = 0; i < this.RuntimeArguments.Count; i++)
                {
                    var argument = this.RuntimeArguments[i];

                    argument.SetupBinding(this, createEmptyBindings);
                }

                this.RuntimeArguments.QuickSort(RuntimeArgument.EvaluationOrderComparer);
            }
        }

        // Note that this is relative to the type of walk we've done. If we skipped implementation
        // then we can still be "Cached" even though we never ignored the implementation.
        /// <summary>
        /// Sets the cached.
        /// </summary>
        /// <param name="isSkippingPrivateChildren">
        /// if set to <c>true</c> [is skipping private children].
        /// </param>
        internal void SetCached(bool isSkippingPrivateChildren) =>
            this.isMetadataCached = isSkippingPrivateChildren ? CacheStates.Partial : CacheStates.Full;

        // We use these Set methods rather than a setter on the property since we don't want to make
        // it seem like setting these collections is the "normal" thing to do. Only
        // OnInternalCacheMetadata implementations should call these methods.
        /// <summary>
        /// Sets the children collection.
        /// </summary>
        /// <param name="children">The children.</param>
        internal void SetChildrenCollection(Collection<Activity> children) => this.Children = children;

        /// <summary>
        /// Sets the delegates collection.
        /// </summary>
        /// <param name="delegates">The delegates.</param>
        internal void SetDelegatesCollection(Collection<ActivityDelegate> delegates) => this.Delegates = delegates;

        /// <summary>
        /// Sets the implementation children collection.
        /// </summary>
        /// <param name="implementationChildren">The implementation children.</param>
        internal void SetImplementationChildrenCollection(Collection<Activity> implementationChildren) => this.ImplementationChildren = implementationChildren;

        /// <summary>
        /// Sets the implementation delegates collection.
        /// </summary>
        /// <param name="implementationDelegates">The implementation delegates.</param>
        internal void SetImplementationDelegatesCollection(Collection<ActivityDelegate> implementationDelegates) =>
            this.ImplementationDelegates = implementationDelegates;

        /// <summary>
        /// Sets the implementation variables collection.
        /// </summary>
        /// <param name="implementationVariables">The implementation variables.</param>
        internal void SetImplementationVariablesCollection(Collection<Variable>? implementationVariables) =>
            this.ImplementationVariables = implementationVariables;

        /// <summary>
        /// Sets the imported children collection.
        /// </summary>
        /// <param name="importedChildren">The imported children.</param>
        internal void SetImportedChildrenCollection(Collection<Activity> importedChildren) => this.ImportedChildren = importedChildren;

        /// <summary>
        /// Sets the imported delegates collection.
        /// </summary>
        /// <param name="importedDelegates">The imported delegates.</param>
        internal void SetImportedDelegatesCollection(Collection<ActivityDelegate> importedDelegates) => this.ImportedDelegates = importedDelegates;

        /// <summary>
        /// Sets the runtime ready.
        /// </summary>
        internal void SetRuntimeReady() => this.isMetadataCached |= CacheStates.RuntimeReady;

        /// <summary>
        /// Sets the temporary validation error collection.
        /// </summary>
        /// <param name="validationErrors">The validation errors.</param>
        internal void SetTempValidationErrorCollection(IList<ValidationError> validationErrors) => this.tempValidationErrors = validationErrors;

        /// <summary>
        /// Sets the variables collection.
        /// </summary>
        /// <param name="variables">The variables.</param>
        internal void SetVariablesCollection(Collection<Variable> variables) => this.RuntimeVariables = variables;

        /// <summary>
        /// Transfers the temporary validation errors.
        /// </summary>
        /// <param name="newList">The new list.</param>
        internal void TransferTempValidationErrors(ref IList<ValidationError> newList)
        {
            if (this.tempValidationErrors != null)
            {
                for (var i = 0; i < this.tempValidationErrors.Count; i++)
                {
                    ActivityUtilities.Add(ref newList, this.tempValidationErrors[i]);
                }
            }

            this.tempValidationErrors = null;
        }

        /// <summary>
        /// Caches the metadata.
        /// </summary>
        /// <param name="metadata">The metadata.</param>
        protected virtual void CacheMetadata(ActivityMetadata metadata)
        {
            var information = new ReflectedInformation(this);

            this.SetImportedChildrenCollection(information.GetChildren());
            this.SetVariablesCollection(information.GetVariables());
            this.SetImportedDelegatesCollection(information.GetDelegates());
            this.SetArgumentsCollection(information.GetArguments(), metadata.CreateEmptyBindings);
        }

        /// <summary>
        /// Called when [create dynamic update map].
        /// </summary>
        /// <param name="metadata">The metadata.</param>
        /// <param name="originalActivity">The original activity.</param>
        protected virtual void OnCreateDynamicUpdateMap(UpdateMapMetadata metadata, Activity originalActivity)
        {
        }

        /// <summary>
        /// Clears the cached metadata.
        /// </summary>
        private void ClearCachedMetadata()
        {
            this.SymbolCount = 0;

            this.RuntimeArguments = null;

            this.Children = null;
            this.ImplementationChildren = null;
            this.ImportedChildren = null;

            this.Delegates = null;
            this.ImplementationDelegates = null;
            this.ImportedDelegates = null;

            this.RuntimeVariables = null;
            this.ImplementationVariables = null;
        }

        /// <summary>
        /// Initializes the relationship.
        /// </summary>
        /// <param name="parent">The parent.</param>
        /// <param name="isPublic">if set to <c>true</c> [is public].</param>
        /// <param name="relationship">The relationship.</param>
        /// <param name="validationErrors">The validation errors.</param>
        /// <returns><c>true</c> if XXXX, <c>false</c> otherwise.</returns>
        private bool InitializeRelationship(Activity parent, bool isPublic, RelationshipType relationship, ref IList<ValidationError> validationErrors)
        {
            if (this.CacheId == parent.CacheId)
            {
                // This means that we've already encountered a parent in the tree

                // Validate that it is visible.

                // In order to see the activity the new parent must be in the implementation IdSpace
                // of an activity which has a public reference to it.
                var referenceTarget = parent.MemberOf.Owner;

                if (ReferenceEquals(this, parent))
                {
                    ActivityUtilities.Add(ref validationErrors, new ValidationError(
                        SR.ActivityCannotReferenceItself(this.DisplayName), parent));

                    return false;
                }
                else if (this.Parent == null)
                {
                    ActivityUtilities.Add(ref validationErrors, new ValidationError(
                        SR.RootActivityCannotBeReferenced(this.DisplayName, parent.DisplayName), parent));

                    return false;
                }
                else if (referenceTarget == null)
                {
                    ActivityUtilities.Add(ref validationErrors, new ValidationError(
                        SR.ActivityCannotBeReferencedWithoutTarget(this.DisplayName, parent.DisplayName, this.Parent.DisplayName), parent));

                    return false;
                }
                else if (!referenceTarget.Children.Contains(this) && !referenceTarget.ImportedChildren.Contains(this))
                {
                    ActivityUtilities.Add(ref validationErrors, new ValidationError(
                        SR.ActivityCannotBeReferenced(
                            this.DisplayName,
                            parent.DisplayName,
                            referenceTarget.DisplayName,
                            this.Parent.DisplayName),
                        false,
                        parent));

                    return false;
                }

                // This is a valid reference so we want to allow normal processing to proceed.
                return true;
            }

            this.Parent = parent;
            this.HandlerOf = null;
            this.RootActivity = parent.RootActivity;
            this.CacheId = parent.CacheId;
            this.isMetadataCached = CacheStates.Uncached;
            this.ClearCachedMetadata();
            this.RelationshipToParent = relationship;

            if (isPublic)
            {
                this.MemberOf = parent.MemberOf;
            }
            else
            {
                if (parent.ParentOf == null)
                {
                    parent.ParentOf = new IdSpace(parent.MemberOf, parent.InternalId);
                }

                this.MemberOf = parent.ParentOf;
            }

            return true;
        }

        /// <summary>
        /// The RootProperties class.
        /// </summary>
        /// <remarks>information used by root activities</remarks>
        private class RootProperties
        {
            /// <summary>
            /// The activity extension providers
            /// </summary>
            private Dictionary<Type, WorkflowInstanceExtensionProvider> activityExtensionProviders;

            /// <summary>
            /// The required extension types
            /// </summary>
            private HashSet<Type> requiredExtensionTypes;

            /// <summary>
            /// The singleton activity names
            /// </summary>
            private Dictionary<string, Activity> singletonActivityNames;

            /// <summary>
            /// Initializes a new instance of the <see cref="RootProperties" /> class.
            /// </summary>
            public RootProperties()
            {
            }

            /// <summary>
            /// Gets the default extensions count.
            /// </summary>
            /// <value>The default extensions count.</value>
            public int DefaultExtensionsCount => this.activityExtensionProviders == null ? 0 : this.activityExtensionProviders.Count;

            /// <summary>
            /// Gets or sets the equivalence information.
            /// </summary>
            /// <value>The equivalence information.</value>
            public ValidationHelper.OverloadGroupEquivalenceInfo EquivalenceInfo
            {
                get;
                set;
            }

            /// <summary>
            /// Gets or sets a value indicating whether this instance has been associated with an instance.
            /// </summary>
            /// <value>
            /// <c>true</c> if this instance has been associated with an instance; otherwise, <c>false</c>.
            /// </value>
            public bool HasBeenAssociatedWithAnInstance
            {
                get;
                set;
            }

            /// <summary>
            /// Gets or sets the host environment.
            /// </summary>
            /// <value>The host environment.</value>
            public LocationReferenceEnvironment HostEnvironment
            {
                get;
                set;
            }

            /// <summary>
            /// Gets or sets the overload groups.
            /// </summary>
            /// <value>The overload groups.</value>
            public Dictionary<string, List<RuntimeArgument>> OverloadGroups
            {
                get;
                set;
            }

            /// <summary>
            /// Gets or sets the required arguments not in overload groups.
            /// </summary>
            /// <value>The required arguments not in overload groups.</value>
            public List<RuntimeArgument> RequiredArgumentsNotInOverloadGroups
            {
                get;
                set;
            }

            /// <summary>
            /// Gets the required extension types count.
            /// </summary>
            /// <value>The required extension types count.</value>
            public int RequiredExtensionTypesCount => this.requiredExtensionTypes == null ? 0 : this.requiredExtensionTypes.Count;

            /// <summary>
            /// Adds the default extension provider.
            /// </summary>
            /// <typeparam name="T"></typeparam>
            /// <param name="extensionProvider">The extension provider.</param>
            public void AddDefaultExtensionProvider<T>(Func<T> extensionProvider)
                where T : class
            {
                var key = typeof(T);
                if (this.activityExtensionProviders == null)
                {
                    this.activityExtensionProviders = new Dictionary<Type, WorkflowInstanceExtensionProvider>();
                }
                else
                {
                    if (this.activityExtensionProviders.ContainsKey(key))
                    {
                        return; // already have a provider of this type
                    }
                }

                this.activityExtensionProviders.Add(key, new WorkflowInstanceExtensionProvider<T>(extensionProvider));

                // if we're providing an extension that exactly matches a required type, simplify
                // further bookkeeping
                if (this.requiredExtensionTypes != null)
                {
                    this.requiredExtensionTypes.Remove(key);
                }
            }

            /// <summary>
            /// Declares the singleton activity.
            /// </summary>
            /// <param name="name">The name.</param>
            /// <param name="activity">The activity.</param>
            public void DeclareSingletonActivity(string name, Activity activity)
            {
                if (this.singletonActivityNames == null)
                {
                    this.singletonActivityNames = new Dictionary<string, Activity>(1);
                }

                this.singletonActivityNames.Add(name, activity);
            }

            /// <summary>
            /// Gets the activity extension information.
            /// </summary>
            /// <param name="activityExtensionProviders">The activity extension providers.</param>
            /// <param name="requiredActivityExtensionTypes">The required activity extension types.</param>
            /// <returns><c>true</c> if XXXX, <c>false</c> otherwise.</returns>
            public bool GetActivityExtensionInformation(
                out Dictionary<Type, WorkflowInstanceExtensionProvider> activityExtensionProviders,
                out HashSet<Type> requiredActivityExtensionTypes)
            {
                activityExtensionProviders = this.activityExtensionProviders;
                requiredActivityExtensionTypes = this.requiredExtensionTypes;
                return activityExtensionProviders != null || (this.requiredExtensionTypes != null && this.requiredExtensionTypes.Count > 0);
            }

            /// <summary>
            /// Gets the singleton activity.
            /// </summary>
            /// <param name="name">The name.</param>
            /// <returns>Activity.</returns>
            public Activity GetSingletonActivity(string name)
            {
                Activity result = null;
                if (this.singletonActivityNames != null)
                {
                    this.singletonActivityNames.TryGetValue(name, out result);
                }

                return result;
            }

            /// <summary>
            /// Determines whether [is singleton activity declared] [the specified name].
            /// </summary>
            /// <param name="name">The name.</param>
            /// <returns>
            /// <c>true</c> if [is singleton activity declared] [the specified name]; otherwise, <c>false</c>.
            /// </returns>
            public bool IsSingletonActivityDeclared(string name) =>
                this.singletonActivityNames == null ? false : this.singletonActivityNames.ContainsKey(name);

            /// <summary>
            /// Requires the extension.
            /// </summary>
            /// <param name="extensionType">Type of the extension.</param>
            public void RequireExtension(Type extensionType)
            {
                // if we're providing an extension that exactly matches a required type, don't
                // bother with further bookkeeping
                if (this.activityExtensionProviders != null && this.activityExtensionProviders.ContainsKey(extensionType))
                {
                    return;
                }

                if (this.requiredExtensionTypes == null)
                {
                    this.requiredExtensionTypes = new HashSet<Type>();
                }

                this.requiredExtensionTypes.Add(extensionType);
            }
        }
    }

    /// <summary>
    /// The Activity class. Implements the <see cref="System.Activities.ActivityWithResult" />
    /// </summary>
    /// <typeparam name="TResult">The type of the t result.</typeparam>
    /// <seealso cref="System.Activities.ActivityWithResult" />
    [TypeConverter(typeof(ActivityWithResultConverter))]
    [ValueSerializer(typeof(ActivityWithResultValueSerializer))]
    public abstract class Activity<TResult> : ActivityWithResult
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="Activity{TResult}" /> class.
        /// </summary>
        protected Activity()
            : base()
        {
        }

        /// <summary>
        /// Gets or sets the result.
        /// </summary>
        /// <value>The result.</value>
        [DefaultValue(null)]
        public new OutArgument<TResult> Result
        {
            get;
            set;
        }

        /// <summary>
        /// Gets the type of the internal result.
        /// </summary>
        /// <value>The type of the internal result.</value>
        internal override Type InternalResultType => typeof(TResult);

        /// <summary>
        /// Gets or sets the result core.
        /// </summary>
        /// <value>The result core.</value>
        internal override OutArgument ResultCore
        {
            get => this.Result;
            set
            {
                this.Result = value as OutArgument<TResult>;

                if (this.Result == null && value != null)
                {
                    throw FxTrace.Exception.Argument(nameof(value), SR.ResultArgumentMustBeSpecificType(typeof(TResult)));
                }
            }
        }

        /// <summary>
        /// Froms the value.
        /// </summary>
        /// <param name="constValue">The constant value.</param>
        /// <returns>Activity&lt;TResult&gt;.</returns>
        [SuppressMessage("Design", "CA1000:Do not declare static members on generic types", Justification = "Generic needed for type inference")]
        public static Activity<TResult> FromValue(TResult constValue) => new Literal<TResult> { Value = constValue };

        /// <summary>
        /// Froms the variable.
        /// </summary>
        /// <param name="variable">The variable.</param>
        /// <returns>Activity&lt;TResult&gt;.</returns>
        [SuppressMessage("Design", "CA1000:Do not declare static members on generic types", Justification = "Generic needed for type inference")]
        public static Activity<TResult> FromVariable(Variable variable)
        {
            if (variable == null)
            {
                throw FxTrace.Exception.ArgumentNull(nameof(variable));
            }

            if (TypeHelper.AreTypesCompatible(variable.Type, typeof(TResult)))
            {
                return new VariableValue<TResult> { Variable = variable };
            }
            else
            {
                if (ActivityUtilities.IsLocationGenericType(typeof(TResult), out var locationGenericType))
                {
                    if (locationGenericType == variable.Type)
                    {
                        return (Activity<TResult>)ActivityUtilities.CreateVariableReference(variable);
                    }
                }
            }

            throw FxTrace.Exception.Argument(
                nameof(variable),
                SR.ConvertVariableToValueExpressionFailed(
                    variable.GetType().FullName,
                    typeof(Activity<TResult>).FullName));
        }

        /// <summary>
        /// Froms the variable.
        /// </summary>
        /// <param name="variable">The variable.</param>
        /// <returns>Activity&lt;TResult&gt;.</returns>
        [SuppressMessage("Design", "CA1000:Do not declare static members on generic types", Justification = "Generic needed for type inference")]
        public static Activity<TResult> FromVariable(Variable<TResult> variable)
        {
            if (variable == null)
            {
                throw FxTrace.Exception.ArgumentNull(nameof(variable));
            }

            return new VariableValue<TResult>(variable);
        }

        /// <summary>
        /// Performs an implicit conversion from <see cref="TResult" /> to <see
        /// cref="Activity{TResult}" />.
        /// </summary>
        /// <param name="constValue">The constant value.</param>
        /// <returns>The result of the conversion.</returns>
        [SuppressMessage("Usage", "CA2225:Operator overloads have named alternates", Justification = "False positive. See FromValue.")]
        public static implicit operator Activity<TResult>(TResult constValue) => FromValue(constValue);

        /// <summary>
        /// Performs an implicit conversion from <see cref="Variable" /> to <see
        /// cref="Activity{TResult}" />.
        /// </summary>
        /// <param name="variable">The variable.</param>
        /// <returns>The result of the conversion.</returns>
        public static implicit operator Activity<TResult>(Variable variable) => FromVariable(variable);

        /// <summary>
        /// Performs an implicit conversion from <see cref="Variable{TResult}" /> to <see
        /// cref="Activity{TResult}" />.
        /// </summary>
        /// <param name="variable">The variable.</param>
        /// <returns>The result of the conversion.</returns>
        public static implicit operator Activity<TResult>(Variable<TResult> variable) => FromVariable(variable);

        /// <summary>
        /// Internals the execute in resolution context.
        /// </summary>
        /// <param name="resolutionContext">The resolution context.</param>
        /// <returns>TResult.</returns>
        internal virtual TResult InternalExecuteInResolutionContext(CodeActivityContext resolutionContext) =>
            throw Fx.AssertAndThrow("This should only be called on CodeActivity<T>");

        /// <summary>
        /// Internals the execute in resolution context untyped.
        /// </summary>
        /// <param name="resolutionContext">The resolution context.</param>
        /// <returns>System.Object.</returns>
        internal override object InternalExecuteInResolutionContextUntyped(CodeActivityContext resolutionContext) =>
            this.InternalExecuteInResolutionContext(resolutionContext);

        /// <summary>
        /// Determines whether [is result argument] [the specified argument].
        /// </summary>
        /// <param name="argument">The argument.</param>
        /// <returns>
        /// <c>true</c> if [is result argument] [the specified argument]; otherwise, <c>false</c>.
        /// </returns>
        internal override bool IsResultArgument(RuntimeArgument argument) => ReferenceEquals(argument, this.ResultRuntimeArgument);

        /// <summary>
        /// Called when [internal cache metadata].
        /// </summary>
        /// <param name="createEmptyBindings">if set to <c>true</c> [create empty bindings].</param>
        internal sealed override void OnInternalCacheMetadata(bool createEmptyBindings)
        {
            this.OnInternalCacheMetadataExceptResult(createEmptyBindings);

            var foundResult = false;

            // This could be null at this point
            var runtimeArguments = this.RuntimeArguments;
            if (runtimeArguments != null)
            {
                var runtimeArgumentCount = runtimeArguments.Count;
                for (var i = 0; i < runtimeArgumentCount; i++)
                {
                    var argument = runtimeArguments[i];

                    if (argument.Name == "Result")
                    {
                        foundResult = true;

                        if (argument.Type != typeof(TResult) || argument.Direction != ArgumentDirection.Out)
                        {
                            // The user supplied "Result" is incorrect so we log a violation.
                            this.AddTempValidationError(
                                new ValidationError(
                                    SR.ResultArgumentHasRequiredTypeAndDirection(
                                        typeof(TResult),
                                        argument.Direction,
                                        argument.Type)));
                        }
                        else if (!this.IsBoundArgumentCorrect(argument, createEmptyBindings))
                        {
                            // The user supplied "Result" is not bound to the correct argument object.
                            this.AddTempValidationError(new ValidationError(SR.ResultArgumentMustBeBoundToResultProperty));
                        }
                        else
                        {
                            // The user supplied "Result" is correct so we cache it.
                            this.ResultRuntimeArgument = argument;
                        }

                        break;
                    }
                }
            }

            if (!foundResult)
            {
                this.ResultRuntimeArgument = new RuntimeArgument("Result", typeof(TResult), ArgumentDirection.Out);

                if (this.Result == null)
                {
                    if (createEmptyBindings)
                    {
                        this.Result = new OutArgument<TResult>();
                        Argument.Bind(this.Result, this.ResultRuntimeArgument);
                    }
                    else
                    {
                        var tempArgument = new OutArgument<TResult>();
                        Argument.Bind(tempArgument, this.ResultRuntimeArgument);
                    }
                }
                else
                {
                    Argument.Bind(this.Result, this.ResultRuntimeArgument);
                }

                this.AddArgument(this.ResultRuntimeArgument, createEmptyBindings);
            }
        }

        /// <summary>
        /// Called when [internal cache metadata except result].
        /// </summary>
        /// <param name="createEmptyBindings">if set to <c>true</c> [create empty bindings].</param>
        internal virtual void OnInternalCacheMetadataExceptResult(bool createEmptyBindings) =>
            // default to Activity's behavior
            base.OnInternalCacheMetadata(createEmptyBindings);

        /// <summary>
        /// Determines whether [is bound argument correct] [the specified argument].
        /// </summary>
        /// <param name="argument">The argument.</param>
        /// <param name="createEmptyBindings">if set to <c>true</c> [create empty bindings].</param>
        /// <returns>
        /// <c>true</c> if [is bound argument correct] [the specified argument]; otherwise, <c>false</c>.
        /// </returns>
        private bool IsBoundArgumentCorrect(RuntimeArgument argument, bool createEmptyBindings)
        {
            if (createEmptyBindings)
            {
                // We must match if we've gone through RuntimeArgument.SetupBinding with
                // createEmptyBindings == true.
                return ReferenceEquals(argument.BoundArgument, this.Result);
            }
            else
            {
                // Otherwise, if the Result is null then SetupBinding has created a default
                // BoundArgument which is fine. If it is non-null then it had better match.
                return this.Result == null || ReferenceEquals(argument.BoundArgument, this.Result);
            }
        }
    }
}
